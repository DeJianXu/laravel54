
项目统一域名:
    js.com

1. 下载项目：
    composer create-project laravel/laravel laravel54 "5.4.*"

2. 本地启动项目：
    php artisan serve
    或者  php artisan serve --port=8888

3. 保证项目的storage具有读写权限
4. 创建数据库迁移文件表:
    php artisan migrate:install

5. 现在安装完成后进行nginx配置:
    location / {
        try_files $uri $uri/ /index.php?$query_string;
    }

6. 注意路由的先后顺序，有时候如果不规定路由参数的类型，会导致错误的路由拦截：
    Route::get('/posts/create', '\App\Http\Controllers\PostController@create');
    Route::get('/posts/{post}', '\App\Http\Controllers\PostController@show');
    先后顺序的不一样，会出现不同的页面跳转，一定要规定参数的类型

7. 引用wangeditor.js编辑器时，css、fonts、js这三个目录都要存在，并且要在同一级。
8. php artisan tinker
   用来直接测试使用模型，避免总是去创建路由规则

9. 使用php artisan tinker 进行数据填充
    factory(App\Post::class,20)->create();

10. php artisan storage:link  (记得使用此命令生成软连接进行图片资源访问，需要在每台机器上都执行)
    storage/app/public 目录用于存储用户生成的文件，比如可以被公开访问的用户头像，要达到被访问的目的，
    你还需要在public目录下生成一个软连接 storage 指向这个目录。
    你可以通过 php artisan storage:link 命令生成这个软链接。

11. 文件上传时需要开始php的  php_fileinfo扩展
12. 文件上传需要配置\config\filesystems.php 文件的配置项：
    'default' => 'public',

13. 关于容器，IOC控制反转，DI依赖注入的理解：
    13.1 容器：用来装东西的，容器中包含了许多实例对象和服务，当有程序需要时就直接从容器中获取即可，不需要程序
    自己使用“new”来自己实现。
    13.2 IOC控制反转: 将程序可能需要的实例或服务提前申请准备好，程序使用时直接获取，不用自己“new”，
        就好比：
            用户(“程序”)在饭店吃饭目的是为了填饱肚子(“实现程序”)，用户需要吃米饭，肉，鱼(“实例对象或相关服务”)，如果使用普通方式的话，
        用户需要自己先挑选(“new 实例化对象”)米饭，肉，鱼然后自己进行操作处理，最后做出了米饭，肉，鱼然后吃饱了肚子(“实现程序”)。
            但如果使用容器和控制反转时，饭店(“容器”)已经提前准备好了米饭，肉，鱼(“实例对象或相关服务”)，当客户需要吃米饭，肉，鱼时，
        直接对服务员说(“依赖注入”)自己需要米饭，肉，鱼即可马上得到，然后吃饱肚子(“实现程序”)，而且最重要的一点，用户不用担心米饭，肉，鱼不新鲜，
        当米饭，肉，鱼不新鲜时，饭店(“容器”)会自动更换(“升级或切换其他实例对象或服务”)最新鲜的米饭，肉，鱼而用户不需要关心这些问题，只要点菜吃饱(“实现程序”)就行了。
    13.3 DI依赖注入：需要相关服务或实例对象时，在参数中或构造函数中声明即可使用，无需"new"关键字创建

14. 门脸(Facades)模式：静态调用===>即调用服务的静态方法
    例： Cache::get('key');
15. 快速查找门脸类和注入类有哪些函数：
    1. php artisan tinker 下执行 app('log');
    2. https://laravel.com/api/5.4/index.html






